/*import * as Expo from "expo";*/
import * as React from "react";
import { StyleProvider } from "native-base";
import { Provider } from "react-redux";

import configureStore from "./configureStore";
import App from "../App";
import getTheme from "../theme/components";
import variables from "../theme/variables/platform";
import {View} from 'react-native';

import PushNotification from 'react-native-push-notification';

export interface Props {}
export interface State {
  store: Object;
  isLoading: boolean;
  isReady: boolean;
}
export default class Setup extends React.Component<Props, State> {
  constructor() {
    super();
    this.state = {
      isLoading: false,
      store: configureStore(() => this.setState({ isLoading: false })),
      isReady: false
    };

    // var firebaseConfig = {
    //     apiKey: "AIzaSyAWc6EcocxP3PZT_uIViMdQlJV4lGr3jJc",
    //     authDomain: "movies-81c24.firebaseapp.com",
    //     databaseURL: "https://movies-81c24.firebaseio.com",
    //     projectId: "movies-81c24",
    //     storageBucket: "",
    //     messagingSenderId: "67881508082"
    // };
    //
    // firebase.initializeApp(firebaseConfig);
    // console.ignoredYellowBox = [
    //     'Setting a timer'
    // ];
  }
  componentWillMount() {
    this.getLocationAsync();
    this.loadFonts();
    this.initPushNotifications();
  }

  async initPushNotifications() {
      PushNotification.configure({

          // (optional) Called when Token is generated (iOS and Android)
          onRegister: function(token) {
              console.log( 'TOKEN:', token );
          },

          // (required) Called when a remote or local notification is opened or received
          onNotification: function(notification) {
              console.log( 'NOTIFICATION:', notification );

              // process the notification

              // required on iOS only (see fetchCompletionHandler docs: https://facebook.github.io/react-native/docs/pushnotificationios.html)
              notification.finish(PushNotificationIOS.FetchResult.NoData);
          },

          // ANDROID ONLY: GCM Sender ID (optional - not required for local notifications, but is need to receive remote push notifications)
          senderID: "YOUR GCM SENDER ID",

          // IOS ONLY (optional): default: all - Permissions to register.
          permissions: {
              alert: true,
              badge: true,
              sound: true
          },

          // Should the initial notification be popped automatically
          // default: true
          popInitialNotification: true,

          /**
           * (optional) default: true
           * - Specified if permissions (ios) and token (android and ios) will requested or not,
           * - if not, you must call PushNotificationsHandler.requestPermissions() later
           */
          requestPermissions: true,
      });


      PushNotification.localNotification({
          /* Android Only Properties */
          id: '0', // (optional) Valid unique 32 bit integer specified as string. default: Autogenerated Unique ID
          ticker: "My Notification Ticker", // (optional)
          autoCancel: true, // (optional) default: true
          largeIcon: "ic_launcher", // (optional) default: "ic_launcher"
          smallIcon: "ic_notification", // (optional) default: "ic_notification" with fallback for "ic_launcher"
          bigText: "My big text that will be shown when notification is expanded", // (optional) default: "message" prop
          subText: "This is a subText", // (optional) default: none
          color: "red", // (optional) default: system default
          vibrate: true, // (optional) default: true
          vibration: 300, // vibration length in milliseconds, ignored if vibrate=false, default: 1000
          tag: 'some_tag', // (optional) add tag to message
          group: "group", // (optional) add group to message
          ongoing: false, // (optional) set whether this is an "ongoing" notification

          /* iOS and Android properties */
          title: "My Notification Title", // (optional)
              message: "My Notification Message", // (required)
          playSound: false, // (optional) default: true
          soundName: 'default', // (optional) Sound to play when the notification is shown. Value of 'default' plays the default sound. It can be set to a custom sound such as 'android.resource://com.xyz/raw/my_sound'. It will look for the 'my_sound' audio file in 'res/raw' directory and play it. default: 'default' (default sound is played)
          number: '10', // (optional) Valid 32 bit integer specified as string. default: none (Cannot be zero)
          repeatType: 'day', // (Android only) Repeating interval. Could be one of `week`, `day`, `hour`, `minute, `time`. If specified as time, it should be accompanied by one more parameter 'repeatTime` which should the number of milliseconds between each interval
          actions: '["Yes", "No"]',  // (Android only) See the doc for notification actions to know more
  });
  }

  async loadFonts() {
    /*await Expo.Font.loadAsync({
      Roboto: require("native-base/Fonts/Roboto.ttf"),
      Roboto_medium: require("native-base/Fonts/Roboto_medium.ttf"),
      Ionicons: require("@expo/vector-icons/fonts/Ionicons.ttf")
    });*/

    this.setState({ isReady: true });
  }

    async getLocationAsync() {
        /*const { Location, Permissions } = Expo;
        const { status } = await Permissions.askAsync(Permissions.LOCATION);
        if (status === 'granted') {
            return Location.getCurrentPositionAsync({enableHighAccuracy: true});
        } else {
            throw new Error('Location permission not granted');
        }*/
    }

  render() {
    if (!this.state.isReady || this.state.isLoading) {
      /*return <Expo.AppLoading />;*/
      return <View></View>
    }
    return (
      <StyleProvider style={getTheme(variables)}>
        <Provider store={this.state.store}>
          <App />
        </Provider>
      </StyleProvider>
    );
  }
}
